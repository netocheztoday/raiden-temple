<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Raiden and the Wing Chun Temple</title>
<style>
  :root{ --frame-max: 980px; --pad: 10px; }
  html,body{margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #frame{max-width:var(--frame-max); margin:0 auto; padding:0 var(--pad);}

  /* MENU */
  #menu{display:flex;flex-direction:column;align-items:center;gap:14px;padding:18px 0}
  #menu img{max-width:100%;height:auto;border-radius:8px}
  .btn{background:#111;border:2px solid #fff;color:#fff;border-radius:10px;padding:12px 22px;font-size:18px}
  .btn:active{transform:translateY(1px)}

  /* GAME */
  #wrap{position:relative}
  #cvs{display:none;width:100%;height:auto;background:#0b1622;image-rendering:pixelated;border-radius:12px}
  #hud{position:absolute;left:10px;top:10px;display:none;gap:10px;align-items:center}
  .tag{background:#0b0e12;color:#cfe1ff;padding:6px 10px;border-radius:10px;font:14px/1.2 monospace;opacity:.9}
  /* Hearts (SVG) top-right */
  #heartsWrap{position:absolute;right:10px;top:10px;display:none;gap:8px}
  .heart{width:36px;height:36px}
  .heart.off{opacity:.35;filter:grayscale(1)}
  /* TOUCH */
  #controls{display:none;gap:14px;justify-content:space-between;margin:10px 0}
  .pad{flex:1;min-width:90px;height:64px;font-size:22px;border:2px solid #2e3a46;background:#111923;color:#fff;border-radius:14px}
  .pad:active{filter:brightness(1.2)}
  /* EFFECTS + OVERLAYS */
  #flash{position:absolute;inset:0;background:#fff;opacity:0;pointer-events:none;transition:opacity .18s}
  #overlay{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.5)}
  #overlay .box{background:#0b0e12; border:2px solid #fff; border-radius:12px; padding:22px 20px; text-align:center; width:min(90%,420px)}
  #overlay h2{margin:0 0 10px}
  #overlay p{margin:0 0 14px;opacity:.9}
  #overlay .btn{margin:0 8px}
</style>
</head>
<body>
  <div id="frame">
    <!-- MENU -->
    <div id="menu">
      <img src="menu-title.png" alt="Raiden and the Wing Chun Temple" />
      <button class="btn" onclick="startGame()">Play</button>
      <button class="btn" id="musicBtn" onclick="toggleMusic()">Music: On</button>
      <button class="btn" onclick="alert('Credits\nMusic & Art: You\nCode helper: ChatGPT')">Credits</button>
    </div>

    <!-- GAME -->
    <div id="wrap">
      <canvas id="cvs" width="800" height="450"></canvas>

      <!-- HUD -->
      <div id="hud">
        <div id="stageTag" class="tag">Stage: —</div>
        <div id="spriteTag" class="tag">sprite: …</div>
      </div>
      <div id="heartsWrap" aria-label="lives"></div>

      <!-- Effects + Game Over -->
      <div id="flash"></div>
      <div id="overlay">
        <div class="box">
          <h2>Game Over</h2>
          <p>You ran out of lives.</p>
          <button class="btn" onclick="retryLevel()">Retry</button>
          <button class="btn" onclick="backToMenu()">Menu</button>
        </div>
      </div>
    </div>

    <!-- Touch controls -->
    <div id="controls">
      <button class="pad" ontouchstart="keys.left=1"  ontouchend="keys.left=0">◀</button>
      <button class="pad" ontouchstart="keys.right=1" ontouchend="keys.right=0">▶</button>
      <button class="pad" ontouchstart="keys.punch=1" ontouchend="keys.punch=0">J</button>
      <button class="pad" ontouchstart="keys.jump=1"  ontouchend="keys.jump=0">⎵</button>
    </div>
  </div>

<script>
/* ============== AUDIO ============== */
let musicOn = true, currentMusic = "menu";
const tracks = {};
["menu","crane","snake","tiger","gates","temple","victory","gameover","credits","lose"].forEach(n=>{
  const a = new Audio(n+".mp3");
  a.loop = !["victory","gameover","lose"].includes(n);
  tracks[n] = a;
});
function stopAll(){ for(const a of Object.values(tracks)){ a.pause(); a.currentTime=0; } }
function playMusic(name){ if(!musicOn) return; stopAll(); currentMusic=name; tracks[name]?.play().catch(()=>{}); }
function toggleMusic(){
  musicOn = !musicOn;
  document.getElementById("musicBtn").textContent = "Music: " + (musicOn?"On":"Off");
  if(musicOn) playMusic(currentMusic); else stopAll();
}

/* ============== CANVAS ============== */
const cvs = document.getElementById("cvs");
const ctx = cvs.getContext("2d", { alpha:true });
ctx.imageSmoothingEnabled = false;
const W = cvs.width, H = cvs.height;
const GROUND_Y = H - 70;

/* ============== UI refs ============== */
const stageTag = document.getElementById("stageTag");
const spriteTag = document.getElementById("spriteTag");
const heartsWrap = document.getElementById("heartsWrap");
const flashEl   = document.getElementById("flash");
const overlayEl = document.getElementById("overlay");

/* ============== IMAGES ============== */
function loadImg(src){ const i=new Image(); i.src = src+"?v="+Date.now(); return i; }
const BG = {
  room:        loadImg("bg-room.png"),
  field:       loadImg("bg-field.png"),
  crane:       loadImg("bg-crane.png"),
  snake:       loadImg("bg-snake.png"),
  tiger:       loadImg("bg-tiger.png"),
  templegates: loadImg("bg-templegates.png"),
  temple:      loadImg("bg-temple.png"),
  hidden:      loadImg("bg-hidden.png") // optional
};
function drawBg(img){
  if(!img || !img.complete) return;
  const iw = img.naturalWidth, ih = img.naturalHeight;
  const s = Math.max(W/iw, H/ih);
  const dw = Math.floor(iw*s), dh = Math.floor(ih*s);
  const dx = Math.floor((W-dw)/2), dy = Math.floor((H-dh)/2);
  ctx.drawImage(img, dx, dy, dw, dh);
}

/* ============== SPRITE ============== */
let spriteReady=false, FW=0, FH=0, COLS=3, ROWS=3;
const sprite = new Image();
sprite.src = "raiden-sprites.png?v="+Date.now();
sprite.onload = ()=>{ FW=Math.floor(sprite.naturalWidth/COLS); FH=Math.floor(sprite.naturalHeight/ROWS); spriteReady=true; spriteTag.textContent="sprite: ok"; };
sprite.onerror = ()=>{ spriteTag.textContent="sprite: missing"; };

/* ============== PLAYER ============== */
let DRAW_W=64, DRAW_H=96;
const player = { x:80, y:GROUND_Y-DRAW_H, vx:0, vy:0, facing:1, state:"idle", tick:0, jumps:0 };

/* Animations */
const anims = {
  idle:{frames:[0,1,2],speed:12},
  walk:{frames:[3,4,5],speed:8},
  punch:{frames:[6,7],speed:6},
  jump:{frames:[8],speed:12}
};
const keys = { left:0, right:0, jump:0, punch:0 };

/* ============== LEVELS ============== */
function door(x){ return {x, y:GROUND_Y-120, w:44, h:120}; }

const LEVELS = [
  { id:"room", name:"Room", music:"menu", bg:BG.room,
    doors:[door(W-58)], nextLeft:null, nextRight:"field" },

  { id:"field", name:"Field", music:"crane", bg:BG.field,
    doors:[door(14), door(W-58)], pit:{x:Math.floor(W/2)-60, w:120},
    nextLeft:"room", nextRight:"crane" },

  { id:"crane", name:"Crane", music:"crane", bg:BG.crane,
    doors:[door(14), door(W-58)], nextLeft:"field", nextRight:"snake" },

  { id:"snake", name:"Snake", music:"snake", bg:BG.snake,
    doors:[door(14), door(W-58)], nextLeft:"crane", nextRight:"tiger" },

  { id:"tiger", name:"Tiger", music:"tiger", bg:BG.tiger,
    doors:[door(14), door(W-58)], nextLeft:"snake", nextRight:"templegates" },

  { id:"templegates", name:"Temple Gates", music:"gates", bg:BG.templegates,
    doors:[door(14), door(W-58)], nextLeft:"tiger", nextRight:"temple" },

  { id:"temple", name:"Temple", music:"temple", bg:BG.temple,
    doors:[door(14), door(W-58)], nextLeft:"templegates", nextRight:"hidden" },

  { id:"hidden", name:"Hidden Room", music:"temple", bg:(BG.hidden && BG.hidden.complete?BG.hidden:BG.room),
    doors:[door(14), door(W-58)], nextLeft:"temple", nextRight:"room" },
];

let inGame=false, levelIndex=0, lives=3, paused=false;
let entryDir = 0;          // -1 came from right door, +1 came from left door
let doorCooldown = 0;      // frames after spawn to ignore door collisions

/* Hearts (SVG) */
const heartSVG = `<svg viewBox="0 0 64 64" class="heart" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#FFE88A"/><stop offset="1" stop-color="#FFA800"/>
    </linearGradient>
  </defs>
  <path d="M32 56s-4-3-13-10C8 39 4 34 4 26c0-6 5-12 12-12 6 0 10 4 12 7 2-3 6-7 12-7 7 0 12 6 12 12 0 8-4 13-15 20-9 7-13 10-13 10z" fill="url(#g)" stroke="#5a2d00" stroke-width="3"/>
  <circle cx="24" cy="18" r="6" fill="#fff" opacity=".6"/>
</svg>`;

function renderHearts(n){
  let html="";
  for(let i=1;i<=3;i++){
    html+= heartSVG.replace('class="heart"','class="heart'+(i<=n?'':' off')+'"');
  }
  heartsWrap.innerHTML = html;
}

/* FLOW */
function startGame(){
  document.getElementById("menu").style.display="none";
  document.getElementById("cvs").style.display="block";
  document.getElementById("controls").style.display="flex";
  document.getElementById("hud").style.display="flex";
  heartsWrap.style.display="flex";
  lives=3; renderHearts(lives);
  setLevel(0, +1); // entering Room from left (spawn near right door off)
  inGame=true; paused=false;
  requestAnimationFrame(loop);
}

function setLevel(i, cameFromDir=0){
  levelIndex=i;
  entryDir = cameFromDir; // -1 entered via right door, +1 via left door
  doorCooldown = 18;      // ~0.3s at 60fps
  const L=LEVELS[levelIndex];
  stageTag.textContent = "Stage: " + L.name;
  playMusic(L.music);
  // spawn away from the door we came from
  if(entryDir<0){ // came from right side -> spawn near left quarter
    player.x = 120;
  }else if(entryDir>0){ // came from left side -> spawn near right quarter
    player.x = W - 120 - DRAW_W;
  }else{
    player.x = 80;
  }
  player.y=GROUND_Y-DRAW_H; player.vx=0; player.vy=0; player.state="idle"; player.tick=0; player.jumps=0;
}

function retryLevel(){
  lives=3; renderHearts(lives);
  overlayEl.style.display="none"; paused=false;
  setLevel(levelIndex, 0);
}
function backToMenu(){
  overlayEl.style.display="none"; paused=false;
  stopAll();
  document.getElementById("menu").style.display="flex";
  document.getElementById("cvs").style.display="none";
  document.getElementById("controls").style.display="none";
  document.getElementById("hud").style.display="none";
  heartsWrap.style.display="none";
  inGame=false;
}

function nextLevel(dir){
  const L=LEVELS[levelIndex];
  const id = dir<0 ? L.nextLeft : L.nextRight;
  if(!id) return;
  const idx = LEVELS.findIndex(l=>l.id===id);
  if(idx>=0) setLevel(idx, dir); // pass which side we exited
}

function flash(color="#fff", dur=180){
  flashEl.style.background = color;
  flashEl.style.opacity = 0.9;
  setTimeout(()=>{ flashEl.style.opacity = 0; }, dur);
}

/* LOOP */
let last=0;
function loop(t){
  requestAnimationFrame(loop);
  if(!inGame || paused) return;
  const dt = Math.min(33, t-last); last=t;
  update(dt/16.66);
  render();
}

/* HELPERS */
function rectOverlap(ax,ay,aw,ah, bx,by,bw,bh){
  return (ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by);
}

/* UPDATE */
function update(){
  const L = LEVELS[levelIndex];

  // input
  const speed = 2.8;
  player.vx=0;
  if(keys.left){  player.vx=-speed; player.facing=-1; }
  if(keys.right){ player.vx= speed; player.facing= 1; }

  // jump / double-jump (edge on)
  if(keys.jump){
    if(!player._jl){
      player._jl=true;
      const onGround = (player.y >= GROUND_Y - DRAW_H - 0.01);
      if(onGround){ player.vy=-9.2; player.jumps=1; player.state="jump"; }
      else if(player.jumps===1){ player.vy=-8.4; player.jumps=2; player.state="jump"; }
    }
  } else player._jl=false;

  // physics
  player.vy += 0.45;
  player.x  += player.vx;
  player.y  += player.vy;

  // bounds
  player.x = Math.max(0, Math.min(W-DRAW_W, player.x));

  // PIT: no ground collision while over it
  const center = player.x + DRAW_W/2;
  const overPit = L.pit && center > L.pit.x && center < (L.pit.x + L.pit.w);

  // floor collision
  if(!overPit && player.y >= GROUND_Y - DRAW_H){
    player.y = GROUND_Y - DRAW_H;
    if(player.state==="jump") player.state="idle";
    player.vy=0; player.jumps=0;
  }

  // fell -> life loss / game over
  if(player.y > H + 10){
    lives = Math.max(0, lives-1);
    renderHearts(lives);
    tracks.lose?.play().catch(()=>{});
    flash("#fff", 160);
    if(lives === 0){
      stopAll(); tracks.gameover?.play().catch(()=>{});
      overlayEl.style.display="flex";
      paused = true;
      return;
    } else {
      setLevel(levelIndex, 0);
      return;
    }
  }

  // state
  if(keys.punch)      player.state="punch";
  else if(player.vx)  player.state="walk";
  else if(player.state!=="jump") player.state="idle";

  // door overlap (after spawn cooldown)
  if(doorCooldown>0) doorCooldown--;
  else {
    for(const d of (L.doors||[])){
      if(rectOverlap(player.x,player.y,DRAW_W,DRAW_H, d.x,d.y,d.w,d.h)){
        if(d.x < W/2) nextLevel(-1); else nextLevel(+1);
        break;
      }
    }
  }

  player.tick++;
}

/* RENDER */
function render(){
  const L = LEVELS[levelIndex];

  // BG
  drawBg(L.bg || BG.room);

  // ground
  ctx.fillStyle="#7c5537";
  ctx.fillRect(40, GROUND_Y, W-80, 22);

  // pit visual
  if(L.pit){ ctx.fillStyle="#21313f"; ctx.fillRect(L.pit.x, GROUND_Y, L.pit.w, 22); }

  // doors
  ctx.fillStyle="#92c5ba";
  (L.doors||[]).forEach(d=>{
    ctx.fillRect(d.x, d.y, d.w, d.h);
    ctx.strokeStyle="#a86e3f"; ctx.lineWidth=4; ctx.strokeRect(d.x, d.y, d.w, d.h);
  });

  // stage label
  ctx.fillStyle="rgba(11,14,18,.85)";
  ctx.fillRect(18, 14, 160, 34);
  ctx.fillStyle="#cfe1ff";
  ctx.font="16px monospace";
  ctx.fillText("Stage: " + L.name, 26, 36);

  // player
  if(spriteReady){
    const a=anims[player.state], f=a.frames[Math.floor(player.tick/a.speed)%a.frames.length];
    drawFrame(f, Math.round(player.x), Math.round(player.y), player.facing<0);
  }
}

function drawFrame(f, dx, dy, flip){
  const PAD=2, col=f%COLS, row=(f/COLS|0);
  const sx=col*FW+PAD, sy=row*FH+PAD, sw=FW-PAD*2, sh=FH-PAD*2;
  ctx.save();
  if(flip){ ctx.translate(dx+DRAW_W,dy); ctx.scale(-1,1); ctx.drawImage(sprite,sx,sy,sw,sh,0,0,DRAW_W,DRAW_H); }
  else    { ctx.drawImage(sprite,sx,sy,sw,sh,dx,dy,DRAW_W,DRAW_H); }
  ctx.restore();
}

/* INPUT */
addEventListener("keydown", e=>{
  if(e.key==="ArrowLeft"||e.key==="a") keys.left=1;
  if(e.key==="ArrowRight"||e.key==="d") keys.right=1;
  if(e.key===" "||e.key==="ArrowUp"||e.key==="w") keys.jump=1;
  if(e.key==="j"||e.key==="J") keys.punch=1;
});
addEventListener("keyup", e=>{
  if(e.key==="ArrowLeft"||e.key==="a") keys.left=0;
  if(e.key==="ArrowRight"||e.key==="d") keys.right=0;
  if(e.key===" "||e.key==="ArrowUp"||e.key==="w") keys.jump=0;
  if(e.key==="j"||e.key==="J") keys.punch=0;
});
</script>
</body>
</html>
