<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Raiden and the Wing Chun Temple</title>
<style>
  :root{ --frame-max: 980px; --pad: 10px; }
  html,body{margin:0;background:#000;color:#fff;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #frame{max-width:var(--frame-max); margin:0 auto; padding:0 var(--pad);}

  /* MENU */
  #menu{display:flex;flex-direction:column;align-items:center;gap:14px;padding:18px 0}
  #menu img{max-width:100%;height:auto;border-radius:8px}
  .btn{background:#111;border:2px solid #fff;color:#fff;border-radius:10px;padding:12px 22px;font-size:18px}
  .btn:active{transform:translateY(1px)}

  /* GAME */
  #wrap{position:relative}
  #cvs{display:none;width:100%;height:auto;background:#0b1622;image-rendering:pixelated;border-radius:12px}
  #hud{position:absolute;left:10px;top:10px;display:none;gap:8px;align-items:center}
  .tag{background:#0b0e12;color:#cfe1ff;padding:6px 10px;border-radius:10px;font:14px/1.2 monospace;opacity:.9}
  #hearts{display:flex;gap:8px;margin-left:6px}
  .heart{position:relative;width:18px;height:18px;background:#ffd54d;border:2px solid #ffc107;border-radius:4px;
         box-shadow:0 0 0 2px #8b5a00 inset;transform:rotate(-45deg)}
  .heart:before,.heart:after{content:"";position:absolute;width:18px;height:18px;background:#ffd54d;border:2px solid #ffc107;border-radius:50%}
  .heart:before{left:-11px;top:-2px}
  .heart:after{left:-2px;top:-11px}
  .heart.dead{opacity:.25;filter:grayscale(1)}

  /* TOUCH CONTROLS */
  #controls{display:none;gap:14px;justify-content:space-between;margin:10px 0}
  .pad{flex:1;min-width:90px;height:64px;font-size:22px;border:2px solid #2e3a46;background:#111923;color:#fff;border-radius:14px}
  .pad:active{filter:brightness(1.2)}
</style>
</head>
<body>
  <div id="frame">
    <!-- MENU -->
    <div id="menu">
      <img src="menu-title.png" alt="Raiden and the Wing Chun Temple" />
      <button class="btn" onclick="startGame()">Play</button>
      <button class="btn" id="musicBtn" onclick="toggleMusic()">Music: On</button>
      <button class="btn" onclick="alert('Credits\nMusic & Art: You\nCode helper: ChatGPT')">Credits</button>
    </div>

    <!-- GAME -->
    <div id="wrap">
      <canvas id="cvs" width="800" height="450"></canvas>
      <div id="hud">
        <div id="stageTag" class="tag">Stage: —</div>
        <div id="spriteTag" class="tag">sprite: …</div>
        <div id="hearts"></div>
      </div>
    </div>

    <!-- Touch controls -->
    <div id="controls">
      <button class="pad" ontouchstart="keys.left=1"  ontouchend="keys.left=0">◀</button>
      <button class="pad" ontouchstart="keys.right=1" ontouchend="keys.right=0">▶</button>
      <button class="pad" ontouchstart="keys.punch=1" ontouchend="keys.punch=0">J</button>
      <button class="pad" ontouchstart="keys.jump=1"  ontouchend="keys.jump=0">⎵</button>
    </div>
  </div>

<script>
/* ============== AUDIO ============== */
let musicOn = true, currentMusic = "menu";
const tracks = {};
["menu","crane","snake","tiger","gates","temple","victory","gameover","credits"].forEach(n=>{
  const a = new Audio(n+".mp3");
  a.loop = !["victory","gameover"].includes(n);
  tracks[n] = a;
});
function stopAll(){ for(const a of Object.values(tracks)){ a.pause(); a.currentTime=0; } }
function playMusic(name){ if(!musicOn) return; stopAll(); currentMusic=name; tracks[name]?.play(); }
function toggleMusic(){
  musicOn = !musicOn;
  document.getElementById("musicBtn").textContent = "Music: " + (musicOn?"On":"Off");
  if(musicOn) playMusic(currentMusic); else stopAll();
}

/* ============== CANVAS ============== */
const cvs = document.getElementById("cvs");
const ctx = cvs.getContext("2d", { alpha:true });
ctx.imageSmoothingEnabled = false;
const W = cvs.width, H = cvs.height;
const GROUND_Y = H - 70;

/* ============== ASSETS ============== */
const stageTag = document.getElementById("stageTag");
const spriteTag = document.getElementById("spriteTag");
const heartsBox = document.getElementById("hearts");

function loadImg(src){ const i=new Image(); i.src = src+"?v="+Date.now(); return i; }

const BG = {
  room:        loadImg("bg-room.png"),
  field:       loadImg("bg-field.png"),
  crane:       loadImg("bg-crane.png"),
  snake:       loadImg("bg-snake.png"),
  tiger:       loadImg("bg-tiger.png"),
  templegates: loadImg("bg-templegates.png"),
  temple:      loadImg("bg-temple.png"),
  hidden:      loadImg("bg-hidden.png")
};

function drawBg(img){
  if(!img || !img.complete) return;
  const iw = img.naturalWidth, ih = img.naturalHeight;
  const s = Math.max(W/iw, H/ih);
  const dw = Math.floor(iw*s), dh = Math.floor(ih*s);
  const dx = Math.floor((W-dw)/2), dy = Math.floor((H-dh)/2);
  ctx.drawImage(img, dx, dy, dw, dh);
}

/* ============== SPRITE (3x3) ============== */
let spriteReady=false, FW=0, FH=0, COLS=3, ROWS=3;
const sprite = new Image();
sprite.src = "raiden-sprites.png?v="+Date.now();
sprite.onload = ()=>{
  FW = Math.floor(sprite.naturalWidth / COLS);
  FH = Math.floor(sprite.naturalHeight / ROWS);
  spriteReady = true;
  spriteTag.textContent = "sprite: ok";
};
sprite.onerror = ()=>{ spriteTag.textContent = "sprite: missing"; };

/* ============== PLAYER ============== */
let DRAW_W=64, DRAW_H=96;
const player = { x:(W-DRAW_W)/2, y:GROUND_Y-DRAW_H, vx:0, vy:0, facing:1, state:"idle", tick:0, jumps:0 };
const anims = {
  idle:{frames:[0,1,2],speed:12},
  walk:{frames:[3,4,5],speed:8},
  punch:{frames:[6,7],speed:6},
  jump:{frames:[8],speed:12}
};
const keys = { left:0, right:0, jump:0, punch:0 };

/* ============== LEVELS ============== */
function door(x){ return {x, y:GROUND_Y-120, w:44, h:120}; }

const LEVELS = [
  { id:"room", name:"Room", music:"menu", bg:BG.room,
    doors:[door(W-58)], nextLeft:null, nextRight:"field" },            // only RIGHT door

  { id:"field", name:"Field", music:"crane", bg:BG.field,
    doors:[door(14), door(W-58)], pit:{x:Math.floor(W/2)-30, w:60},
    nextLeft:"room", nextRight:"crane" },

  { id:"crane", name:"Crane", music:"crane", bg:BG.crane,
    doors:[door(14), door(W-58)], nextLeft:"field", nextRight:"snake" },

  { id:"snake", name:"Snake", music:"snake", bg:BG.snake,
    doors:[door(14), door(W-58)], nextLeft:"crane", nextRight:"tiger" },

  { id:"tiger", name:"Tiger", music:"tiger", bg:BG.tiger,
    doors:[door(14), door(W-58)], nextLeft:"snake", nextRight:"templegates" },

  { id:"templegates", name:"Temple Gates", music:"gates", bg:BG.templegates,
    doors:[door(14), door(W-58)], nextLeft:"tiger", nextRight:"temple" },

  { id:"temple", name:"Temple", music:"temple", bg:BG.temple,
    doors:[door(14), door(W-58)], nextLeft:"templegates", nextRight:"hidden" },

  { id:"hidden", name:"Hidden Room", music:"temple", bg:(BG.hidden || BG.room),
    doors:[door(14), door(W-58)], nextLeft:"temple", nextRight:"room" },
];

let inGame=false, levelIndex=0, lives=3;

function setHearts(n){
  heartsBox.innerHTML="";
  for(let i=0;i<3;i++){
    const h=document.createElement("div");
    h.className="heart"+(i<n?"":" dead");
    heartsBox.appendChild(h);
  }
}

/* ============== FLOW ============== */
function startGame(){
  document.getElementById("menu").style.display="none";
  document.getElementById("cvs").style.display="block";
  document.getElementById("controls").style.display="flex";
  document.getElementById("hud").style.display="flex";
  lives=3; setHearts(lives);
  setLevel(0);
  inGame=true;
  requestAnimationFrame(loop);
}
function gameOver(){
  stopAll(); tracks.gameover?.play();
  alert("Game Over!");
  inGame=false;
  document.getElementById("menu").style.display="flex";
  document.getElementById("cvs").style.display="none";
  document.getElementById("controls").style.display="none";
  document.getElementById("hud").style.display="none";
}
function setLevel(i){
  levelIndex=i;
  const L=LEVELS[levelIndex];
  stageTag.textContent="Stage: "+L.name;
  playMusic(L.music);
  player.x=80; player.y=GROUND_Y-DRAW_H; player.vx=0; player.vy=0; player.state="idle"; player.tick=0; player.jumps=0;
}
function nextLevel(dir){
  const L=LEVELS[levelIndex];
  const id = dir<0?L.nextLeft:L.nextRight;
  if(!id) return;
  const idx = LEVELS.findIndex(l=>l.id===id);
  if(idx>=0) setLevel(idx);
}

/* ============== LOOP ============== */
let last=0;
function loop(t){
  requestAnimationFrame(loop);
  if(!inGame) return;
  const dt = Math.min(33, t-last); last=t;
  update(dt/16.66);
  render();
}

/* ============== UPDATE ============== */
function rectOverlap(ax,ay,aw,ah, bx,by,bw,bh){
  return (ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by);
}

function update(dt){
  const L = LEVELS[levelIndex];

  // input
  const speed = 2.8;
  player.vx=0;
  if(keys.left){  player.vx=-speed; player.facing=-1; }
  if(keys.right){ player.vx= speed; player.facing= 1; }

  // jump / double-jump
  if(keys.jump){
    if(!player._jl){
      player._jl=true;
      const onGround = (player.y >= GROUND_Y - DRAW_H - 0.01);
      if(onGround){ player.vy=-9.2; player.jumps=1; player.state="jump"; }
      else if(player.jumps===1){ player.vy=-8.4; player.jumps=2; player.state="jump"; }
    }
  } else player._jl=false;

  // physics
  player.vy += 0.45;
  player.x  += player.vx;
  player.y  += player.vy;

  // horizontal bounds
  player.x = Math.max(0, Math.min(W-DRAW_W, player.x));

  // PIT logic: only collide with floor when NOT over the pit
  const center = player.x + DRAW_W/2;
  const overPit = L.pit && center > L.pit.x && center < (L.pit.x + L.pit.w);

  // floor collision
  if(!overPit && player.y >= GROUND_Y - DRAW_H){
    player.y = GROUND_Y - DRAW_H;
    if(player.state==="jump") player.state="idle";
    player.vy=0; player.jumps=0;
  }

  // fell below screen => lose life & respawn
  if(player.y > H){
    lives = Math.max(0, lives-1);
    setHearts(lives);
    if(lives===0){ gameOver(); return; }
    setLevel(levelIndex);
    return;
  }

  // state machine
  if(keys.punch)      player.state="punch";
  else if(player.vx)  player.state="walk";
  else if(player.state!=="jump") player.state="idle";

  // door collision
  for(const d of (L.doors||[])){
    if(rectOverlap(player.x, player.y, DRAW_W, DRAW_H, d.x, d.y, d.w, d.h)){
      if(d.x < W/2) nextLevel(-1); else nextLevel(+1);
      break;
    }
  }

  player.tick++;
}

/* ============== RENDER ============== */
function render(){
  const L = LEVELS[levelIndex];
  drawBg(L.bg || BG.room);

  // ground
  ctx.fillStyle="#7c5537";
  ctx.fillRect(40, GROUND_Y, W-80, 22);

  // pit visual
  if(L.pit){
    ctx.fillStyle="#21313f";
    ctx.fillRect(L.pit.x, GROUND_Y, L.pit.w, 22);
  }

  // doors
  ctx.fillStyle="#92c5ba";
  (L.doors||[]).forEach(d=>{
    ctx.fillRect(d.x, d.y, d.w, d.h);
    ctx.strokeStyle="#a86e3f"; ctx.lineWidth=4; ctx.strokeRect(d.x, d.y, d.w, d.h);
  });

  // player
  if(spriteReady){
    const a = anims[player.state];
    const f = a.frames[Math.floor(player.tick/a.speed)%a.frames.length];
    drawFrame(f, Math.round(player.x), Math.round(player.y), player.facing<0);
  }
}

function drawFrame(f, dx, dy, flip){
  const PAD=2, col=f%COLS, row=(f/COLS|0);
  const sx=col*FW+PAD, sy=row*FH+PAD, sw=FW-PAD*2, sh=FH-PAD*2;
  ctx.save();
  if(flip){ ctx.translate(dx+DRAW_W,dy); ctx.scale(-1,1); ctx.drawImage(sprite,sx,sy,sw,sh,0,0,DRAW_W,DRAW_H); }
  else    { ctx.drawImage(sprite,sx,sy,sw,sh,dx,dy,DRAW_W,DRAW_H); }
  ctx.restore();
}

/* ============== INPUT ============== */
addEventListener("keydown", e=>{
  if(e.key==="ArrowLeft"||e.key==="a") keys.left=1;
  if(e.key==="ArrowRight"||e.key==="d") keys.right=1;
  if(e.key===" "||e.key==="ArrowUp"||e.key==="w") keys.jump=1;
  if(e.key==="j"||e.key==="J") keys.punch=1;
});
addEventListener("keyup", e=>{
  if(e.key==="ArrowLeft"||e.key==="a") keys.left=0;
  if(e.key==="ArrowRight"||e.key==="d") keys.right=0;
  if(e.key===" "||e.key==="ArrowUp"||e.key==="w") keys.jump=0;
  if(e.key==="j"||e.key==="J") keys.punch=0;
});
</script>
</body>
</html>
